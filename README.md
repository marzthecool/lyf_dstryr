# ðŸ’¥ Lyf Dstryr 5000 ðŸ’¥ #
### By: ###
__Arturo Montes de Oca Barrios__

__Mary Laura Carmona MartÃ­nez__

## Project Description ##
The ðŸ’¥ Lyf Dstryr 5000 ðŸ’¥ is an Elixir program that emulates a ramsomware attack.

This program will find and encrypt a given file **located within the provided directory**. 

The encryption will be done using the Galois/Counter Mode algorithm. 
The Galois/Counter Mode algorithm is a mode of operation for symmetric-key cryptographic block ciphers which is widely adopted for its performance. The operation is an authenticated encryption algorithm designed to provide both data authenticity (integrity) and confidentiality. GCM is defined for block ciphers with a block size of 128 bits.

By entering the secret key, the program will decrypt the previously affected files.
     
Our project doesn't need any additional libraries, it instead relies on Erlang to do the encryption part.

## Language: ## 
Elixir

## Compiling the program ## 
Run in the root directory:
```
iex.bat lyfDestryr.exs
```

## Executing the program ## 
To encrypt a file:
```
LyfDestryr.main("./Data/Test_#.txt", "./Encrypted/Test_#_ENCRYPTED.txt", "encrypt")
```

To decrypt a file:
```
LyfDestryr.main("./Encrypted/Test_#_ENCRYPTED.txt", "./Decrypted/Test_#_DECRYPTED.txt", "decrypt")
```

## Proposed solution: ##
### Encrypting function ###
#### Generating the Secret Key ####
The key was generated by creating a binary composed of 16 random bytes using Erlang's `:crypto.strong_rand_bytes/1`. Then the binary is converted to base 64 using Erlag's `:base64.encode/1`, obtaining a string that's stored in a file. This key is used during both encrypt and decrypt files. 

#### Encrypting Plaintext ####
We used `:crypto.block_encrypt/4` to do our encryption.

The function `block_encrypt` returns the tuple:
```
{ciphertext, ciphertag}
```
The ciphertext is the encrypted version of our original plaintext. The ciphertag is the "message authentication code", or MAC. This is a short piece of information used to authenticate a messageâ€”in other words, to confirm that the message came from the stated sender and has not been changed. The MAC value protects both a message's data integrity as well as its authenticity, by allowing verifiers to detect any changes to the message content.


The `block_encrypt` function needs the following arguments:
* The mode of encryption we want to implement:

     We used the Advanced Encryption Standard Galois Counter Mode.
* The secret key we want to use for encryption:

     We used the key in its binary form.
* The initialization vector:
     
     The initialization vector is a random, fixed-size input that is used to enable block encryption to securely encrypt plaintext of any size.
     Every time we perform encryption, a different random set of bytes is mixed with the first block of input data. Then the ciphertext from the first block's encryption is added to the second block, the ciphertext from the second block is added to the third and so on. This provides semantic security. 
     Every time we encrypt the same string, we end up with different ciphertext, thereby ensuring that an attacker can't make any conclusions about the original plaintext by observing the encrypted ciphertext.
* The string we want to encrypt.
     
     It is the value to be encrypted.
     
#### Returning the Encrypted Data ####
In order to be able to decrypt the encrypted data, we need to use the ciphertext, the ciphertag and the initialization vector. So, our function returns a binary that is concatenation of these three pieces of data. And to make it easier to store our encrypted data, we transformed this binary into a base-64 encoded string.


### Decrypting function ###
#### Decrypting Ciphertext ####
For this, we relied on `:crypto.block_decrypt/4`.

The four arguments we need to give `block_decrypt` are:

* The mode of encryption

     We used the Advanced Encryption Standard Galois Counter Mode.
* The secret key

     It is the previously stored key used in the encryption.
* The initialization vector

     It is the same value we used during encryption.
* The ciphertext to decrypt

     It is the encrypted plain text that our encryption function returned.


### Other tools ###
We used the following Elixir modules:
* [Enum](https://hexdocs.pm/elixir/1.12.3/Enum.html)
* [String](https://hexdocs.pm/elixir/1.12.3/String.html)
* [File](https://hexdocs.pm/elixir/1.12.3/File.html)
* [Path](https://hexdocs.pm/elixir/1.12.3/Path.html)

We used the following Erlang modules:
* [Crypto](erlang.org/documentation/doc-9.2/lib/crypto-4.2/doc/html/crypto.html#block_decrypt-4)

The following topics are applied to our solution:
* Functional programming

     Our program will be written in Elixir, which is a functional program that will allows us to build our application using functions.
* Lists

     We used lists to easily manage and process the data we worked with.
* File I/O

     We worked with reading and writing files.

## References ##
* IBM. (2015). Galois/Counter Mode (GCM). https://www.ibm.com/docs/en/zos/2.3.0?topic=operation-galoiscounter-mode-gcm
